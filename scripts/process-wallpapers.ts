/**
 * Wallpaper Image Processing Script
 *
 * Reads source images from data/wallpapers-source/ and generates:
 * 1. Optimized AVIF + WebP versions at multiple sizes in public/wallpapers/
 * 2. A TypeScript manifest file that the app imports to know which wallpapers exist
 *
 * Premium themes are dynamically generated from whatever images exist in the
 * source folder ‚Äî no hardcoded wallpaper list needed.
 *
 * Usage: npm run images:process
 */
import sharp from 'sharp';
import { readdir, mkdir, stat, writeFile } from 'node:fs/promises';
import { join, parse, extname } from 'node:path';

// Configuration
const SOURCE_DIR = 'data/wallpapers-source';
const OUTPUT_DIR = 'public/wallpapers';
const MANIFEST_PATH = 'features/Preferences/data/wallpapers.generated.ts';
const SUPPORTED_EXTENSIONS = new Set([
  '.jpg',
  '.jpeg',
  '.png',
  '.webp',
  '.avif',
  '.gif',
  '.tiff',
  '.bmp',
]);
const WIDTHS = [1920, 2560, 3840];

const AVIF_OPTIONS: sharp.AvifOptions = { quality: 65, effort: 6 };
const WEBP_OPTIONS: sharp.WebpOptions = { quality: 78 };

interface ProcessResult {
  source: string;
  baseName: string;
  displayName: string;
  outputs: { file: string; size: number; format: string; width: number }[];
  originalSize: number;
  error?: string;
}

/**
 * Convert kebab-case filename to Title Case display name
 * e.g. "neon-city-nights" ‚Üí "Neon City Nights"
 */
function toDisplayName(baseName: string): string {
  return baseName
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

async function getSourceImages(): Promise<string[]> {
  try {
    const entries = await readdir(SOURCE_DIR);
    return entries
      .filter(file => {
        const ext = extname(file).toLowerCase();
        return SUPPORTED_EXTENSIONS.has(ext);
      })
      .sort(); // Deterministic order
  } catch {
    console.error(`‚ùå Source directory not found: ${SOURCE_DIR}`);
    console.error(
      '   Create the directory and add source images. See data/wallpapers-source/README.md',
    );
    process.exit(1);
  }
}

async function processImage(filename: string): Promise<ProcessResult> {
  const sourcePath = join(SOURCE_DIR, filename);
  const baseName = parse(filename).name;
  const result: ProcessResult = {
    source: filename,
    baseName,
    displayName: toDisplayName(baseName),
    outputs: [],
    originalSize: 0,
  };

  try {
    const fileStat = await stat(sourcePath);
    result.originalSize = fileStat.size;

    const image = sharp(sourcePath);
    const metadata = await image.metadata();

    if (!metadata.width || !metadata.height) {
      result.error = 'Could not read image dimensions';
      return result;
    }

    console.log(
      `  Processing: ${filename} (${metadata.width}√ó${metadata.height})`,
    );

    for (const width of WIDTHS) {
      // Skip sizes larger than original
      if (width > metadata.width) {
        console.log(
          `    Skipping ${width}w (larger than source ${metadata.width}w)`,
        );
        continue;
      }

      // Generate AVIF
      const avifName = `${baseName}-${width}w.avif`;
      const avifPath = join(OUTPUT_DIR, avifName);
      const avifInfo = await sharp(sourcePath)
        .resize(width, undefined, { withoutEnlargement: true })
        .avif(AVIF_OPTIONS)
        .toFile(avifPath);

      result.outputs.push({
        file: avifName,
        size: avifInfo.size,
        format: 'avif',
        width,
      });

      // Generate WebP
      const webpName = `${baseName}-${width}w.webp`;
      const webpPath = join(OUTPUT_DIR, webpName);
      const webpInfo = await sharp(sourcePath)
        .resize(width, undefined, { withoutEnlargement: true })
        .webp(WEBP_OPTIONS)
        .toFile(webpPath);

      result.outputs.push({
        file: webpName,
        size: webpInfo.size,
        format: 'webp',
        width,
      });
    }
  } catch (err) {
    result.error = err instanceof Error ? err.message : String(err);
  }

  return result;
}

function formatBytes(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

/**
 * Generate the TypeScript manifest file that the app imports.
 * This is the single source of truth for which wallpapers exist.
 */
function generateManifest(results: ProcessResult[]): string {
  const successful = results.filter(r => !r.error);

  const entries = successful
    .map(r => {
      return `  {
    id: '${r.baseName}',
    name: '${r.displayName}',
    url: '/wallpapers/${r.baseName}-1920w.avif',
    urlWebp: '/wallpapers/${r.baseName}-1920w.webp',
  },`;
    })
    .join('\n');

  return `/**
 * AUTO-GENERATED ‚Äî DO NOT EDIT MANUALLY
 *
 * Generated by: npm run images:process
 * Source: data/wallpapers-source/
 *
 * Each entry corresponds to a source image that was processed into
 * AVIF + WebP at 1920w, 2560w, and 3840w sizes in public/wallpapers/.
 */

export interface GeneratedWallpaper {
  /** Unique ID derived from source filename (kebab-case) */
  id: string;
  /** Human-readable display name (auto-generated from filename) */
  name: string;
  /** Primary AVIF URL (1920w default size) */
  url: string;
  /** WebP fallback URL (1920w default size) */
  urlWebp: string;
}

/**
 * All available wallpapers, dynamically generated from source images.
 * The number of entries here directly determines the number of Premium themes.
 */
export const GENERATED_WALLPAPERS: GeneratedWallpaper[] = [
${entries}
];
`;
}

async function main() {
  console.log('üñºÔ∏è  Wallpaper Image Processor');
  console.log('‚îÅ'.repeat(50));

  // Ensure output directory exists
  await mkdir(OUTPUT_DIR, { recursive: true });

  const sourceFiles = await getSourceImages();

  if (sourceFiles.length === 0) {
    console.log(`\n‚ö†Ô∏è  No source images found in ${SOURCE_DIR}`);
    console.log('   Add images and run this script again.');
    // Still generate an empty manifest so the app compiles
    const emptyManifest = generateManifest([]);
    await writeFile(MANIFEST_PATH, emptyManifest, 'utf-8');
    console.log(`\nüìù Generated empty manifest: ${MANIFEST_PATH}`);
    return;
  }

  console.log(`\nüìÅ Found ${sourceFiles.length} source image(s)\n`);

  const results: ProcessResult[] = [];
  let totalOutputs = 0;
  let totalOutputSize = 0;
  let totalOriginalSize = 0;
  let errors = 0;

  for (const file of sourceFiles) {
    const result = await processImage(file);
    results.push(result);

    if (result.error) {
      console.error(`    ‚ùå Error: ${result.error}`);
      errors++;
    } else {
      totalOriginalSize += result.originalSize;
      for (const output of result.outputs) {
        totalOutputs++;
        totalOutputSize += output.size;
      }
    }
  }

  // Generate manifest
  const manifest = generateManifest(results);
  await writeFile(MANIFEST_PATH, manifest, 'utf-8');

  // Print summary
  console.log('\n' + '‚îÅ'.repeat(50));
  console.log('üìä Summary');
  console.log('‚îÅ'.repeat(50));

  for (const result of results) {
    if (result.error) {
      console.log(`  ‚ùå ${result.source}: ${result.error}`);
      continue;
    }

    console.log(`  ‚úÖ ${result.source} (${formatBytes(result.originalSize)})`);

    for (const output of result.outputs) {
      const ratio = ((output.size / result.originalSize) * 100).toFixed(1);
      console.log(
        `     ‚Üí ${output.file}: ${formatBytes(output.size)} (${ratio}% of original)`,
      );
    }
  }

  console.log('\n' + '‚îÅ'.repeat(50));
  console.log(`  Files processed: ${results.length}`);
  console.log(`  Outputs generated: ${totalOutputs}`);
  console.log(`  Total source size: ${formatBytes(totalOriginalSize)}`);
  console.log(`  Total output size: ${formatBytes(totalOutputSize)}`);

  if (totalOriginalSize > 0) {
    const avgRatio = (
      (totalOutputSize / (totalOriginalSize * (totalOutputs / 2))) *
      100
    ).toFixed(1);
    console.log(`  Avg compression ratio: ~${avgRatio}%`);
  }

  if (errors > 0) {
    console.log(`\n  ‚ö†Ô∏è  ${errors} file(s) had errors`);
  }

  const successCount = results.filter(r => !r.error).length;
  console.log(`\nüìù Generated manifest: ${MANIFEST_PATH}`);
  console.log(
    `   ‚Üí ${successCount} wallpaper(s) ‚Üí ${successCount} Premium theme(s)`,
  );
  console.log('‚îÅ'.repeat(50));
  console.log('\n‚ú® Done! Run `npm run dev` to see your Premium themes.');
}

main().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
